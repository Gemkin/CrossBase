<#@ template debug="true" hostspecific="false" language="C#" inherits="Templates.TemplateBase"  #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Language" #>

<#+
    public string ClassName;
	public string ProxyName;
	public string InterfaceName;
	public string ProxyNamespace;
	public List<string> CustomDefaultNamespaces;
    private string attributeName;

    public override void Render()
	{
		debugOutput = string.Empty;
        attributeName = "DispatchProxy";
        var classes = Parser.GetAllClassesThatHaveAnAttribute(attributeName);

		foreach (var @class in classes)
		{
			foreach(var attribute in @class.Attributes)
			{
				if (attribute.Name != attributeName)
					continue; 
						
				ProxyName = @class.Name;
				ProxyNamespace = @class.Namespace.Name;
				InterfaceName = attribute.GetArgument("InterfaceName");
				ClassName = attribute.GetArgument("ClassName");
				
				var fileName = attribute.FileName;
				var projectItem = Parser.GetProjectItem(fileName);
				var outputFileName = fileName.Replace(".cs", "." + InterfaceName + "." + attributeName + ".g.cs");

				if (string.IsNullOrEmpty(InterfaceName))
				{
					debugOutput += string.Format("InterfaceName not set on " + attributeName + " attribute on class {0}\r\n", @class.Name);		
					continue;
				}

				var @interface = Parser.Interfaces.Find(f=> f.Name == InterfaceName);
				if (@interface == null)
				{
					debugOutput += string.Format("Interface {1} not found " + attributeName + " attribute on class {0}\r\n", @class.Name, InterfaceName);		
					continue;
				}

			    var useDefaultRule = false;
				if (string.IsNullOrEmpty(ClassName))
				{
					debugOutput += string.Format("ClassName to proxy not set on " + attributeName + " attribute on class {0}, using default name derived from interface name\r\n", @class.Name);
				    useDefaultRule = true;
				}


				var fieldName =  useDefaultRule ? @interface.GetDefaultPrivateFieldName() : ClassName.ChangeFirstChar(ChangeCase.ToLower);
				var propertyName = useDefaultRule? @interface.GetDefaultPropertyName() : ClassName;


			    var containsNotifyPropertyChanged = @interface.AllEvents.Exists(s => s.Name == "PropertyChanged");

				GenerateHeader();
			    var usings = new List<string>
			        {
			            "System",
			            "CrossBase.Dispatch",
			            "CrossBase.Serialization",
			        };
				if (containsNotifyPropertyChanged)
					usings.Add("System.ComponentModel");
				GenerateUsings(@class, usings);
#>
using <#=  @interface.Namespace.Name #>;

namespace <#= ProxyNamespace #>	
{
	public interface I<#= ProxyName  #> 
	{
		<#= @interface.Name #> <#= propertyName #> { get; set; }
		IDispatcher UpDispatcher { get; set; }
        IDispatcher DownDispatcher { get; set; }
<#+			foreach (var function in @interface.AllFunctions)
				{#>
		event EventHandler<EventArgs> <#= function.Name #>Started;
		event EventHandler<EventArgs> <#= function.Name #>Finished;
<#+
				}

				foreach (var prop in @interface.AllProperties)
				{ #>
		<#= prop.Type #> <#= prop.Name #>Invoke { get; set; } 
<#+
					if (containsNotifyPropertyChanged)
					{#>
		<#= prop.Type #> <#= prop.Name #>BeginInvoke { get; set; } 
<#+
					}
				}

				foreach (var func in @interface.AllFunctions)
				{ #>
		<#= func.InterfaceSignature(string.Empty, "BeginInvoke") #>;
		<#= func.InterfaceSignature(string.Empty, "Invoke") #>;
<#+
				}
#>
	}

	public partial class <#= ProxyName  #>: I<#= ProxyName  #> <#+ if (containsNotifyPropertyChanged){#>, INotifyPropertyChanged<#+}#>

	{
		public IDispatcher UpDispatcher { get; set; }
        public IDispatcher DownDispatcher { get; set; }
        
<#+				foreach (var evnt in @interface.AllEvents)
				{#>
		public event <#= evnt.Type #> <#= evnt.Name #>;
<#+
				}
#>
<#+
				foreach (var prop in @interface.AllProperties)
				{ 
					if (containsNotifyPropertyChanged)
					{#>
		private <#= prop.Type #> <#= prop.GetDefaultPrivateFieldName() #>BeginInvoke;
		public <#= prop.Type #> <#= prop.Name #>BeginInvoke 
		{
			get
			{
				return <#= prop.GetDefaultPrivateFieldName() #>;
			}
			set
			{
				if (value is ICloneable)
				{
					value = (<#= prop.Type #>)(clone as ICloneable).Clone();
				}
				DownDispatcher.BeginInvoke(() => 
				{
					if (value == <#= fieldName #>.<#= prop.Name #>)
						return;
					<#= fieldName #>.<#= prop.Name #> = value; 
				});

			}
		}
<#+
				    }
					else
					{#>
		private <#= prop.Type #> <#= prop.GetDefaultPrivateFieldName() #>Invoke;

		public <#= prop.Type #> <#= prop.Name #>Invoke 
		{
			get
			{
				var value = <#= prop.GetDefaultPrivateFieldName() #>Invoke;
				DownDispatcher.Invoke(() => 
				{
					value = <#= fieldName #>.<#= prop.Name #>;
					if (value is ICloneable)
					{
						value = (<#= prop.Type #>)(value as ICloneable).Clone();
					}					 
				});
				return value;
			}
			set
			{
				if (value is ICloneable)
				{
					value = (<#= prop.Type #>)(value as ICloneable).Clone();
				}
				DownDispatcher.Invoke(() => 
				{
					if (value == <#= fieldName #>.<#= prop.Name #>)
						return;
					<#= fieldName #>.<#= prop.Name #> = value; 
				});
			}
		}				    
<#+					}
				}
				foreach (var function in @interface.AllFunctions)
				{#>
		public event EventHandler<EventArgs> <#= function.Name #>Started;
		public event EventHandler<EventArgs> <#= function.Name #>Finished;
		
		private void Invoke<#= function.Name #>Started(EventArgs e)
	    {
	       	var handler = <#= function.Name #>Started;
	       	if (handler != null) handler(this, e);
	    }
			
		private void Invoke<#= function.Name #>Finished(EventArgs e)
	    {
	       	var handler = <#= function.Name #>Finished;
	       	if (handler != null) handler(this, e);
	    }	
		<#+
				}
				#>
		private  <#= @interface.Name #> <#= fieldName #>;
			
		public <#=  @interface.Name #> <#= propertyName #>
		{
			get
			{
				return <#= fieldName #>;
			}
			set
			{			
				if (<#= fieldName #> != null) 
					UnsubscribeTo<#= propertyName #>();

				<#= fieldName #> = value;
				SubscribeTo<#= propertyName #>();
			}
		}
<#+
				foreach (var evnt in @interface.AllEvents)
				{
					if (evnt.Name == "PropertyChanged")
					{
#>
		private void On<#= evnt.Name #>Handler(object sender, PropertyChangedEventArgs e)
		{
			switch (e.PropertyName)
			{
<#+
						foreach (var property in @interface.AllProperties)
						{
#>
				case "<#= property.Name #>":
					{
						var propClone = <#= fieldName #>.<#= property.Name #>;
						if (<#= fieldName #>.<#= property.Name #> is ICloneable)
						{
							propClone = (<#= property.Type #>)(propClone as ICloneable).Clone();
						}
						UpDispatcher.BeginInvoke(() =>
							{
								<#= property.GetDefaultPrivateFieldName() #> = propClone;
								var handler = PropertyChanged;
								if (handler != null) handler(this, new PropertyChangedEventArgs(e.PropertyName));
							});

						break;
					}
<#+
						}
#>
					
			}
		}

<#+
						
					}
					else
					{
#>
		private void On<#= evnt.Name #>Handler(object sender, <#= evnt.GenericEventHandlerType #> e)
		{
		    var eventArgs = e;
			if (eventArgs is ICloneable)
			{
				eventArgs = (<#= evnt.GenericEventHandlerType #>)(eventArgs as ICloneable).Clone();
			}
			UpDispatcher.BeginInvoke(() =>
				{
					var handler = <#= evnt.Name #>;
					if (handler != null) handler(this, eventArgs);
				});
		}
<#+
					}
				}
#>
		public void UnsubscribeTo<#= propertyName #>()
		{
			if (<#= fieldName #> == null)
				return;
<#+
				foreach (var evnt in @interface.AllEvents)
				{
#>
			<#= fieldName #>.<#= evnt.Name #> -= On<#= evnt.Name #>Handler;
<#+
				}
		#>
		}		

		private void SubscribeTo<#= propertyName #>()
		{
<#+
				foreach (var evnt in @interface.AllEvents)
				{
#>
			<#= fieldName #>.<#= evnt.Name #> += On<#= evnt.Name #>Handler;
<#+
				}
		#>
		}

<#+
				foreach (var function in @interface.AllFunctions)
				{#>
		<#= function.Signature("", "BeginInvoke") #>
		{
			DownDispatcher.BeginInvoke(() => 
				{
					UpDispatcher.BeginInvoke(() => Invoke<#= function.Name #>Started(EventArgs.Empty));
					try
					{
						<#= fieldName #>.<#= function.CallSignature("") #>;
					}
					finally
					{
						UpDispatcher.BeginInvoke(() => Invoke<#= function.Name #>Finished(EventArgs.Empty));
					}
				});
		}
		<#= function.Signature("", "Invoke") #>
		{
			DownDispatcher.Invoke(() => 
				{
					Invoke<#= function.Name #>Started(EventArgs.Empty);
					try
					{
						<#= fieldName #>.<#= function.CallSignature("") #>;
					}
					finally
					{
						Invoke<#= function.Name #>Finished(EventArgs.Empty);
					}
				});
		}



<#+				}#>
	}
}

<#+
				GenerateFooter();
				debugOutput += string.Format("Generated {0}\r\n", outputFileName);
				Delete(projectItem, outputFileName);
				Save(projectItem, outputFileName);
			}
		}
		base.Render();
	}

#>
